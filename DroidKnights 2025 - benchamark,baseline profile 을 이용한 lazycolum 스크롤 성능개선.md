# DroidKnights 2025 발표 정리

## Benchmark와 BaselineProfile을 사용해 LazyColumn 스크롤 성능을 75% 개선하기까지의 여정  
**발표자: 송상윤 (펜타시큐리티 안드로이드 개발자)**

---

## 1. 안드로이드 앱 컴파일 3단계

### 1. 자바/코틀린 컴파일 단계
- 코틀린 소스 코드는 `Kotlin CC` 컴파일러를 통해 `.jar` 파일로 패키징됨
- `.jar`에는 `.class` 바이트코드, 코틀린 확장 함수 포함

### 2. R8 컴파일 단계
- `.class` → `.dex` 변환
- `.dex` 파일 + 리소스 → `.apk` 생성
- `.apk`는 `.zip` 확장자로 변경 시 내부 덱스 파일 확인 가능

### 3. AOT와 JIT 컴파일 단계
- **AOT (Ahead-Of-Time)**: 앱 설치 시 `.dex` → 기계어(.oat, .vdex)로 컴파일
- **JIT (Just-In-Time)**: 앱 실행 중 실시간으로 `.dex` → 기계어 컴파일
- 현재는 AOT + JIT 혼합 하이브리드 방식 (ART 가상 머신)

---

## 2. 벤치마크 성능 측정 옵션

### 🔧 `compilationMode` 옵션
- `none`: JIT 기반, 성능 낮음
- `full`: 전체 AOT, 설치 속도/용량 이슈, 실사용 환경과 다름
- `partial`: 하이브리드 AOT+JIT, 실사용 환경과 가장 유사  
  → **Baseline Profile을 통해 AOT 대상 사전 지정 가능**

### 📈 `metrics` 옵션: `FrameTimingMetric`
- 목표: 60 FPS → 16.67ms/frame
- `Choreographer`: V-Sync 타이밍에 맞춰 렌더링 스케줄링
- 지표:
  - `frameDurationCpuMs`: CPU가 한 프레임을 그리는 시간
  - `frameOverrunMs`: 렌더링 지연 시간 (16.67ms 초과분)

### 🎯 시사점
- `frameDurationCpuMs`의 **P50 > 16.67ms** → 렌더링 이슈 있음
- `frameOverrunMs`의 **P99 < 0** → 성능 양호

---

## 3. UI 성능 개선 여정 (버디스탁 앱 사례)

### 3.1 문제 정의 및 진단
- 리스트 진입 지연 (1~2초), 스크롤 버벅임 발생
- 리컴포지션 이슈 X
- 프레임당 렌더링 시간: **908.6ms**
- LazyColumn 내 **이미지 컴포저블** 병목 원인 확인

### 🧪 원인 확인 과정
- 이미지 → `Box` 컴포저블 대체 → 908.6ms → **13.8ms**로 개선

---

### 3.2 최적화 단계

#### 1. 고용량 레스터 이미지 → **비동기 로딩 (Coil)**
- `PainterResource` → 메인 스레드 블로킹 발생
- `AsyncImagePainter`로 변경
- **frameOverrunMs: 1초 → 24.1ms 개선**
- **Perfetto 평균: 590μs**

#### 2. 레스터 이미지 → **XML 벡터 이미지**
- Google 권고에 따라 변경
- **Perfetto 평균: 400μs**

#### 3. XML 벡터 이미지 → **Kotlin 타입 벡터 이미지**
- `loadVectorResource` 제거로 메인 스레드 작업 최소화
- **Perfetto 평균: 80μs**

#### 4. Material 3 라디오 버튼 → **Box로 커스텀**
- 기존: 260μs → 변경 후: **100μs**

#### 5. 컴포즈 렌더링 최적화 (리컴포지션 제거)

##### 🧱 기본 3단계
1. Composition
2. Layout
3. Drawing  
→ 단방향 흐름, 중간 단계에서 상태 변경 시 재컴포지션 발생

##### 🎯 문제: 스크롤에 따라 폰트 크기 변화 시 수백 회 리컴포지션 발생

##### 🛠️ 해결책 1: `Modifier.layout` 활용
- 컴포지션 단계가 아닌 **레이아웃 단계**에서 상태값 읽기

##### 🔥 문제 발생: 함수 추출 시 재컴포지션 재발

##### 🛠️ 해결책 2: **람다 타입(() → Float)**으로 상태 전달
- `fontSize: () -> Float`로 상태를 전달
- 컴포즈가 참조 동등성 비교로 리컴포지션 방지

---

## 4. 최종 성능 개선 요약

| 단계                        | 개선 전      | 개선 후        |
| --------------------------- | ------------ | -------------- |
| 레스터 이미지 → Coil 비동기 | 1초          | 24.1ms (590μs) |
| XML 벡터 이미지             | 590μs        | 400μs          |
| 코틀린 벡터 이미지          | 300μs        | 80μs           |
| M3 라디오 버튼              | 260μs        | 100μs          |
| 리컴포지션 제거             | 수백 회 발생 | 0회 발생       |

---

## 5. Q&A 및 추가 논의

- **벤치마크**: 정성적 판단용, 신뢰성 한계 존재
- **Perfetto**: 코드 외 성능 병목까지 추적 가능, 미시적 분석에 강점
- **고용량 이미지**: 수백 KB ~ 수 MB, 뷰 시스템에선 OK → Compose에선 병목
- **성능 최적화 범위**: 이미지/리컴포지션 외에도 다양한 가능성 존재
- **네이티브 개발자의 강점**: OS 구조와 가까워 직접적 성능 튜닝에 강점

---

## 🔚 결론

- LazyColumn 최적화는 단순한 문제 해결이 아닌, **렌더링 단계별 원인 분석과 도구 사용**이 결합된 과정이었음
- 성능 병목은 의외로 사소한 UI 컴포넌트나 API 호출 하나에서도 발생할 수 있음
- "장인정신"을 발휘한 최적화는 사용자에게는 체감되지 않을 수 있으나, **개발자 경험과 시스템 이해도에 깊이를 더해줌**